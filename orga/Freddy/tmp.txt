static int	handle_invalid_export(char *arg)
{
	ft_putstr_fd("export: not a valid identifier\n", STDERR_FILENO);
	return (1);
}

static char	*create_export_arg(t_gc *gc, char *arg)
{
	char	*export_arg;

	export_arg = ft_shell_strjoin(gc, arg, "=");
	export_arg = ft_shell_strjoin(gc, export_arg, "");
	return (export_arg);
}

static int	process_argument(t_gc *gc, char **env, char *arg)
{
	char	*var_name;
	int		has_errors;

	has_errors = 0;
	if (arg && ft_strchr(arg, '='))
	{
		if (arg[0] == '=' || arg[ft_strlen(arg) - 1] == '=')
			has_errors = handle_invalid_export(arg);
		else
		{
			var_name = find_variable(gc, arg);
			if (is_valid_identifier(var_name))
				*env = change_or_add_env_var(gc, arg, *env);
			else
				has_errors = handle_invalid_export(arg);
			free(var_name);
		}
	}
	else
	{
		if (is_valid_identifier(arg))
		{
			char	*export_arg = create_export_arg(gc, arg);
			*env = change_or_add_env_var(gc, export_arg, *env);
			free(export_arg);
		}
		else
			has_errors = handle_invalid_export(arg);
	}
	return (has_errors);
}

static int	handle_args(t_gc *gc, char **env, char **args)
{
	int	has_errors;
	int	i;

	has_errors = 0;
	i = 0;
	while (args[i])
	{
		has_errors |= process_argument(gc, &env, args[i]);
		i++;
	}
	return (has_errors);
}

int	built_in_export(t_shell *shell)
{
	t_gc	*gc;
	char	**args;
	char	**env;

	gc = &shell->gc;
	env = shell->env;
	args = shell->cmds_head->args;
	if (!args || !args[0])
	{
		print_export_env(gc, env);
		return (0);
	}
	if (handle_args(gc, env, args))
		return (1);
	shell->env = env;
	return (0);
}
